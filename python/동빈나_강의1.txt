컴퓨터는 2진수 체계이므로 실수형을 제대로 표현하지 못 할 수 있다.
ex) a = 0.3 b = 0.6 -> print(a+b) -> 0.8999999999999..

즉, 개발 과정에서 실수 값을 제대로 비교하지 못해 원하는 결과를 얻지 못할 수 있다
따라서 round()함수가 권장된다.(반올림 함수라고 보면 된다.)
ex) round(123.456, 2) -> 123.46

==========================================================

문자열 : 특정 인덱스의 값을 바꿀 순 없다.

튜플
* 한 번 선언된 값을 변경할 수 없다.
* 소괄호를 이용한다.
* 인덱스로 접근할 수 있다. -> 순서 있다
- 언제 쓸까?
1. 서로 다른 성질의 데이터를 묶어서 관리해야 할 때
ex) 최단 경로 알고리즘에서 (비용, 노드 번호)
2. 데이터의 나열을 해싱의 키 값으로 사용해야 할 때 -> 변경 불가능 하므로
3. 메모리를 효율적으로 사용해야 할 때(리스트보다)

===========================================================

dictionary
* key, value 쌍
* 변경 불가능한 자료형을 키로 사용할 수 있다.
* 초기화 ex) data = dict()
* 데이터 조회, 수정에 있어 O(1) 에 처리 가능

set
* 중복 불허
* 순서 없음
* 리스트, 문자열을 이용해 초기화할 수 있다. -> set() 함수 이용
* 중괄호 이용 { }
* 데이터 조회, 수정에 있어 O(1) 에 처리 가능
* 합집합(|), 교집합(&), 차집합(-) 연산 가능
* 함수 add(새로운 원소 추가), update(새로운 원소 여러개 추가), remove

=============================================================
***중요!!******************

람다 표현식
* 함수를 한 줄에 작성할 수 있다.
ex) print((lambda a,b: a+b)(3,7)) -> 10
ex) array = [('홍길동', 50), ('이순신', 32), ('아무개', 74)]
print(sorted(array, key= lambda x: x[1])) -> 이순신, 홍길동, 아무개 순으로 정렬
ex) list1 = [1,2,3,4,5] list2 = [6,7,8,9,10]
result = map(lambda a,b: a+b, list1, list2)
print(list(result)) -> [7,9,11,13,15]

=============================================================
유용한 표준 라이브러리
itertools -> 순열 조합
heapq -> 우선순위 큐
bisect -> 이진탐색 기능
collections -> deque, Counter(등장횟수 세기)
math -> 팩토리얼, 제곱근, 최대공약수, 삼각함수, 파이...